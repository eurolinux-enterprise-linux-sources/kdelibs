diff --git a/plasma/private/wallpaper_p.h b/plasma/private/wallpaper_p.h
index 3207413..02ff1c7 100644
--- a/plasma/private/wallpaper_p.h
+++ b/plasma/private/wallpaper_p.h
@@ -21,6 +21,9 @@
 #ifndef PLASMA_WALLPAPERPRIVATE_H
 #define PLASMA_WALLPAPERPRIVATE_H
 
+#include <QtCore/QQueue>
+#include <QtCore/QWeakPointer>
+
 #include "plasma/private/dataengineconsumer_p.h"
 #include "plasma/private/wallpaperrenderthread_p.h"
 
@@ -46,11 +49,8 @@ public:
                      int resizeMethod, const QColor &color) const;
 
 
-    void renderCompleted(int token, const QImage &image,
-                         const QString &sourceImagePath, const QSize &size,
-                         int resizeMethod, const QColor &color);
+    void newRenderCompleted(const WallpaperRenderRequest &render, const QImage &image);
 
-    static WallpaperRenderThread s_renderer;
     static PackageStructure::Ptr s_packageStructure;
 
     Wallpaper *q;
diff --git a/plasma/private/wallpaperrenderthread.cpp b/plasma/private/wallpaperrenderthread.cpp
index 38d74c0..0398d83 100644
--- a/plasma/private/wallpaperrenderthread.cpp
+++ b/plasma/private/wallpaperrenderthread.cpp
@@ -20,197 +20,186 @@
 
 #include "plasma/private/wallpaperrenderthread_p.h"
 
+#include <QCoreApplication>
 #include <QPainter>
 #include <QFile>
 #include <QSvgRenderer>
 
 #include <kdebug.h>
 
+#ifndef PLASMA_NO_SOLID
+#include <solid/device.h>
+#include <solid/deviceinterface.h>
+#endif
+
 namespace Plasma
 {
 
-WallpaperRenderThread::WallpaperRenderThread(QObject *parent)
+int WallpaperRenderRequest::s_token = 0;
+int WallpaperRenderThread::s_rendererCount = 0;
+QQueue<WallpaperRenderRequest> WallpaperRenderThread::s_renderQueue;
+
+WallpaperRenderThread::WallpaperRenderThread(const WallpaperRenderRequest &request, QObject *parent)
     : QThread(parent),
-      m_currentToken(-1)
+      m_request(request),
+      m_abort(false)
 {
-    m_abort = false;
-    m_restart = false;
+    qRegisterMetaType<WallpaperRenderRequest>("WallpaperRenderRequest");
+    if (!request.requester) {
+        deleteLater();
+        return;
+    }
+
+    ++s_rendererCount;
+    connect(this, SIGNAL(done(WallpaperRenderRequest,QImage)),
+            request.requester.data(), SLOT(newRenderCompleted(WallpaperRenderRequest,QImage)));
 }
 
 WallpaperRenderThread::~WallpaperRenderThread()
 {
-    {
-        // abort computation
-        QMutexLocker lock(&m_mutex);
-        m_abort = true;
-        m_condition.wakeOne();
-    }
-
+    kDebug() << "rendering done";
+    m_abort = true;
     wait();
+    --s_rendererCount;
+    checkQueue();
 }
 
-void WallpaperRenderThread::setSize(const QSize& size)
+void WallpaperRenderThread::render(const WallpaperRenderRequest &request)
 {
-    QMutexLocker lock(&m_mutex);
-    m_size = size;
+    QObject *requester = request.requester.data();
+    if (!requester) {
+        return;
+    }
+
+    // remove all dead requests and requests previously made for the same parent
+    QMutableListIterator<WallpaperRenderRequest> it(s_renderQueue);
+    while (it.hasNext()) {
+        const WallpaperRenderRequest &request = it.next();
+
+        if (!request.requester || request.requester.data() == requester) {
+            it.remove();
+        }
+    }
+
+    s_renderQueue.append(request);
+    checkQueue();
 }
 
-int WallpaperRenderThread::render(const QString &file,
-                                  const QSize &size,
-                                  Wallpaper::ResizeMethod method,
-                                  const QColor &color)
+void WallpaperRenderThread::checkQueue()
 {
-    int token;
-    {
-        QMutexLocker lock(&m_mutex);
-        m_file = file;
-        m_color = color;
-        m_method = method;
-        m_size = size;
-        m_restart = true;
-        token = ++m_currentToken;
+    if (s_renderQueue.isEmpty()) {
+        return;
     }
 
-    if (!isRunning()) {
-        start();
-    } else {
-        m_condition.wakeOne();
+    if (QCoreApplication::closingDown()) {
+        s_renderQueue.clear();
+        return;
     }
 
-    return token;
+#ifndef PLASMA_NO_SOLID
+    const int numProcs = qMax(1, Solid::Device::listFromType(Solid::DeviceInterface::Processor).count());
+#else
+    const int numProcs = 1;
+#endif
+    kDebug() << "checking rendering against" << s_rendererCount << numProcs;
+    if (s_rendererCount < numProcs) {
+        WallpaperRenderThread *renderThread = new WallpaperRenderThread(s_renderQueue.dequeue());
+        renderThread->start();
+    }
 }
 
 void WallpaperRenderThread::run()
 {
-    QString file;
-    QColor color;
-    QSize size;
-    qreal ratio;
-    Wallpaper::ResizeMethod method;
-    int token;
-
-    forever {
-        {
-            QMutexLocker lock(&m_mutex);
-
-            while (!m_restart && !m_abort) {
-                m_condition.wait(&m_mutex);
-            }
-
-            if (m_abort) {
-                return;
-            }
+    kDebug() << "rendering wallpaper" << m_request.file;
+    QImage result(m_request.size, QImage::Format_ARGB32_Premultiplied);
+    result.fill(m_request.color.rgba());
 
-            m_restart = false;
-
-            // load all parameters in nonshared variables
-            token = m_currentToken;
-            file = m_file;
-            color = m_color;
-            size = m_size;
-            ratio = m_size.width() / qreal(m_size.height());
-            method = m_method;
-        }
-
-        QImage result(size, QImage::Format_ARGB32_Premultiplied);
-        result.fill(color.rgba());
-
-        if (file.isEmpty() || !QFile::exists(file)) {
-            emit done(token, result, file, size, method, color);
-            break;
+    if (m_request.file.isEmpty() || !QFile::exists(m_request.file)) {
+        if (!m_abort) {
+            emit done(m_request, result);
         }
 
-        QPoint pos(0, 0);
-        bool tiled = false;
-        bool scalable = file.endsWith("svg") || file.endsWith("svgz");
-        QSize scaledSize;
-        QImage img;
-
-        // set image size
-        QSize imgSize;
-        if (scalable) {
-            // scalable: image can be of any size
-            imgSize = size;
-        } else {
-            // otherwise, use the natural size of the loaded image
-            img = QImage(file);
-            imgSize = img.size();
-            //kDebug() << "loaded with" << imgSize << ratio;
-        }
-
-        // if any of them is zero we may run into a div-by-zero below.
-        if (imgSize.width() < 1) {
-            imgSize.setWidth(1);
-        }
-
-        if (imgSize.height() < 1) {
-            imgSize.setHeight(1);
-        }
+        kDebug() << "oh, fuck it";
+        deleteLater();
+        return;
+    }
 
-        if (ratio < 1) {
-            ratio = 1;
-        }
+    QPoint pos(0, 0);
+    //const float ratio = qMax(float(1), m_request.size.width() / float(m_request.size.height()));
+    const bool scalable = m_request.file.endsWith(QLatin1String("svg")) || m_request.file.endsWith(QLatin1String("svgz"));
+    bool tiled = false;
+    QSize scaledSize;
+    QImage img;
+
+    // set image size
+    QSize imgSize(1, 1);
+    if (scalable) {
+        // scalable: image can be of any size
+        imgSize = imgSize.expandedTo(m_request.size);
+    } else {
+        // otherwise, use the natural size of the loaded image
+        img = QImage(m_request.file);
+        imgSize = imgSize.expandedTo(img.size());
+        //kDebug() << "loaded with" << imgSize << ratio;
+    }
 
-        // set render parameters according to resize mode
-        switch (method)
-        {
+    // set render parameters according to resize mode
+    switch (m_request.resizeMethod)
+    {
         case Wallpaper::ScaledResize:
-            imgSize *= ratio;
-            scaledSize = size;
+            scaledSize = m_request.size;
             break;
         case Wallpaper::CenteredResize:
             scaledSize = imgSize;
-            pos = QPoint((size.width() - scaledSize.width()) / 2,
-                        (size.height() - scaledSize.height()) / 2);
+            pos = QPoint((m_request.size.width() - scaledSize.width()) / 2,
+                         (m_request.size.height() - scaledSize.height()) / 2);
 
             //If the picture is bigger than the screen, shrink it
-            if (size.width() < imgSize.width() && imgSize.width() > imgSize.height()) {
-                int width = size.width();
+            if (m_request.size.width() < imgSize.width() && imgSize.width() > imgSize.height()) {
+                int width = m_request.size.width();
                 int height = width * scaledSize.height() / imgSize.width();
                 scaledSize = QSize(width, height);
-                pos = QPoint((size.width() - scaledSize.width()) / 2,
-                             (size.height() - scaledSize.height()) / 2);
-            } else if (size.height() < imgSize.height()) {
-                int height = size.height();
+                pos = QPoint((m_request.size.width() - scaledSize.width()) / 2,
+                        (m_request.size.height() - scaledSize.height()) / 2);
+            } else if (m_request.size.height() < imgSize.height()) {
+                int height = m_request.size.height();
                 int width = height * imgSize.width() / imgSize.height();
                 scaledSize = QSize(width, height);
-                pos = QPoint((size.width() - scaledSize.width()) / 2,
-                             (size.height() - scaledSize.height()) / 2);
+                pos = QPoint((m_request.size.width() - scaledSize.width()) / 2,
+                             (m_request.size.height() - scaledSize.height()) / 2);
             }
 
             break;
         case Wallpaper::MaxpectResize: {
-            imgSize *= ratio;
-            float xratio = (float) size.width() / imgSize.width();
-            float yratio = (float) size.height() / imgSize.height();
+            float xratio = (float) m_request.size.width() / imgSize.width();
+            float yratio = (float) m_request.size.height() / imgSize.height();
             if (xratio > yratio) {
-                int height = size.height();
+                int height = m_request.size.height();
                 int width = height * imgSize.width() / imgSize.height();
                 scaledSize = QSize(width, height);
             } else {
-                int width = size.width();
+                int width = m_request.size.width();
                 int height = width * imgSize.height() / imgSize.width();
                 scaledSize = QSize(width, height);
             }
-            pos = QPoint((size.width() - scaledSize.width()) / 2,
-                        (size.height() - scaledSize.height()) / 2);
+            pos = QPoint((m_request.size.width() - scaledSize.width()) / 2,
+                         (m_request.size.height() - scaledSize.height()) / 2);
             break;
         }
         case Wallpaper::ScaledAndCroppedResize: {
-            imgSize *= ratio;
-            float xratio = (float) size.width() / imgSize.width();
-            float yratio = (float) size.height() / imgSize.height();
+            float xratio = (float) m_request.size.width() / imgSize.width();
+            float yratio = (float) m_request.size.height() / imgSize.height();
             if (xratio > yratio) {
-                int width = size.width();
+                int width = m_request.size.width();
                 int height = width * imgSize.height() / imgSize.width();
                 scaledSize = QSize(width, height);
             } else {
-                int height = size.height();
+                int height = m_request.size.height();
                 int width = height * imgSize.width() / imgSize.height();
                 scaledSize = QSize(width, height);
             }
-            pos = QPoint((size.width() - scaledSize.width()) / 2,
-                        (size.height() - scaledSize.height()) / 2);
+            pos = QPoint((m_request.size.width() - scaledSize.width()) / 2,
+                         (m_request.size.height() - scaledSize.height()) / 2);
             break;
         }
         case Wallpaper::TiledResize:
@@ -219,51 +208,57 @@ void WallpaperRenderThread::run()
             break;
         case Wallpaper::CenterTiledResize:
             scaledSize = imgSize;
-            pos = QPoint(
-                -scaledSize.width() +
-                    ((size.width() - scaledSize.width()) / 2) % scaledSize.width(),
-                -scaledSize.height() +
-                    ((size.height() - scaledSize.height()) / 2) % scaledSize.height());
+            pos = QPoint(-scaledSize.width() + ((m_request.size.width() - scaledSize.width()) / 2) % scaledSize.width(),
+                         -scaledSize.height() + ((m_request.size.height() - scaledSize.height()) / 2) % scaledSize.height());
             tiled = true;
             break;
-        }
+    }
 
-        QPainter p(&result);
-        //kDebug() << token << scalable << scaledSize << imgSize;
-        if (scalable) {
-            // tiling is ignored for scalable wallpapers
-            QSvgRenderer svg(file);
-            if (m_restart) {
-                continue;
-            }
-            svg.render(&p);
-        } else {
-            if (scaledSize != imgSize) {
-                img = img.scaled(scaledSize, Qt::IgnoreAspectRatio, Qt::SmoothTransformation);
-            }
+    QPainter p(&result);
+    //kDebug() << token << scalable << scaledSize << imgSize;
+    if (scalable) {
+        // tiling is ignored for scalable wallpapers
+        QSvgRenderer svg(m_request.file);
+        if (m_abort) {
+            deleteLater();
+        kDebug() << "oh, fuck it 2";
+            return;
+        }
+        svg.render(&p);
+    } else {
+        if (scaledSize != imgSize) {
+            img = img.scaled(scaledSize, Qt::IgnoreAspectRatio, Qt::SmoothTransformation);
+        }
 
-            if (m_restart) {
-                continue;
-            }
+        if (m_abort) {
+            deleteLater();
+        kDebug() << "oh, fuck it 3";
+            return;
+        }
 
-            if (tiled) {
-                for (int x = pos.x(); x < size.width(); x += scaledSize.width()) {
-                    for (int y = pos.y(); y < size.height(); y += scaledSize.height()) {
-                        p.drawImage(QPoint(x, y), img);
-                        if (m_restart) {
-                            continue;
-                        }
+        if (tiled) {
+            for (int x = pos.x(); x < m_request.size.width(); x += scaledSize.width()) {
+                for (int y = pos.y(); y < m_request.size.height(); y += scaledSize.height()) {
+                    p.drawImage(QPoint(x, y), img);
+                    if (m_abort) {
+        kDebug() << "oh, fuck it 4";
+                        deleteLater();
+                        return;
                     }
                 }
-            } else {
-                p.drawImage(pos, img);
             }
+        } else {
+            p.drawImage(pos, img);
         }
+    }
 
-        // signal we're done
-        emit done(token, result, file, size, method, color);
-        break;
+    // signal we're done
+    if (!m_abort) {
+        kDebug() << "*****************************************************";
+        emit done(m_request, result);
     }
+
+    deleteLater();
 }
 
 } // namespace Plasma
diff --git a/plasma/private/wallpaperrenderthread_p.h b/plasma/private/wallpaperrenderthread_p.h
index 201ae68..30ad0ab 100644
--- a/plasma/private/wallpaperrenderthread_p.h
+++ b/plasma/private/wallpaperrenderthread_p.h
@@ -24,6 +24,7 @@
 #include <QColor>
 #include <QImage>
 #include <QMutex>
+#include <QQueue>
 #include <QThread>
 #include <QWaitCondition>
 
@@ -32,42 +33,49 @@
 namespace Plasma
 {
 
+class WallpaperRenderRequest
+{
+public:
+    WallpaperRenderRequest()
+        : token(++s_token)
+    {
+
+    }
+    QWeakPointer<QObject> requester;
+    QString file;
+    QSize size;
+    Wallpaper::ResizeMethod resizeMethod;
+    QColor color;
+    int token;
+
+    static int s_token;
+};
+
 class WallpaperRenderThread : public QThread
 {
     Q_OBJECT
 
 public:
-    WallpaperRenderThread(QObject *parent = 0);
+    WallpaperRenderThread(const WallpaperRenderRequest &request, QObject *parent = 0);
     virtual ~WallpaperRenderThread();
 
-    int render(const QString &file, const QSize &size,
-               Wallpaper::ResizeMethod, const QColor &color);
-
-    void setSize(const QSize &size);
-    void setRatio(float ratio);
+    static void render(const WallpaperRenderRequest &request);
 
 Q_SIGNALS:
-    void done(int token, const QImage &pixmap,
-              const QString &sourceImagePath, const QSize &size,
-              int resizeMethod, const QColor &color);
+    void done(const WallpaperRenderRequest &request, const QImage &image);
 protected:
     virtual void run();
 
 private:
-    QMutex m_mutex; // to protect parameters
-    QWaitCondition m_condition;
-
-    // protected by mutex
-    int m_currentToken;
-    QString m_file;
-    QColor m_color;
-    QSize m_size;
-    float m_ratio;
-    Wallpaper::ResizeMethod m_method;
+    static void checkQueue();
+    WallpaperRenderRequest m_request;
 
     bool m_abort;
-    bool m_restart;
+
+    static int s_rendererCount;
+    static QQueue<WallpaperRenderRequest> s_renderQueue;
 };
 
 } // namespace Plasma
+Q_DECLARE_METATYPE(Plasma::WallpaperRenderRequest);
 #endif // RENDERTHREAD_H
diff --git a/plasma/wallpaper.cpp b/plasma/wallpaper.cpp
index 23064f6..d73ac12 100644
--- a/plasma/wallpaper.cpp
+++ b/plasma/wallpaper.cpp
@@ -24,6 +24,7 @@
 #include <QFile>
 #include <QFileInfo>
 #include <QImage>
+#include <QQueue>
 
 #include <kdebug.h>
 #include <kglobal.h>
@@ -41,15 +42,12 @@
 namespace Plasma
 {
 
-WallpaperRenderThread WallpaperPrivate::s_renderer;
 PackageStructure::Ptr WallpaperPrivate::s_packageStructure(0);
 
 Wallpaper::Wallpaper(QObject * parentObject)
     : d(new WallpaperPrivate(KService::serviceByStorageId(QString()), this))
 {
     setParent(parentObject);
-    connect(&WallpaperPrivate::s_renderer, SIGNAL(done(int,QImage,QString,QSize,int,QColor)),
-            this, SLOT(renderCompleted(int,QImage,QString,QSize,int,QColor)));
 }
 
 Wallpaper::Wallpaper(QObject *parentObject, const QVariantList &args)
@@ -65,8 +63,6 @@ Wallpaper::Wallpaper(QObject *parentObject, const QVariantList &args)
     }
 
     setParent(parentObject);
-    connect(&WallpaperPrivate::s_renderer, SIGNAL(done(int,QImage,QString,QSize,int,QColor)),
-            this, SLOT(renderCompleted(int,QImage,QString,QSize,int,QColor)));
 }
 
 Wallpaper::~Wallpaper()
@@ -333,7 +329,14 @@ void Wallpaper::render(const QString &sourceImagePath, const QSize &size,
         }
     }
 
-    d->renderToken = WallpaperPrivate::s_renderer.render(sourceImagePath, size, resizeMethod, color);
+    WallpaperRenderRequest request;
+    d->renderToken = request.token;
+    request.requester = this;
+    request.file = sourceImagePath;
+    request.size = size;
+    request.resizeMethod = resizeMethod;
+    request.color = color;
+    WallpaperRenderThread::render(request);
     //kDebug() << "rendering" << sourceImagePath << ", token is" << d->renderToken;
 }
 
@@ -351,17 +354,16 @@ QString WallpaperPrivate::cachePath(const QString &key) const
     return KGlobal::dirs()->locateLocal("cache", "plasma-wallpapers/" + key + ".png");
 }
 
-void WallpaperPrivate::renderCompleted(int token, const QImage &image,
-                                       const QString &sourceImagePath, const QSize &size,
-                                       int resizeMethod, const QColor &color)
+void WallpaperPrivate::newRenderCompleted(const WallpaperRenderRequest &request, const QImage &image)
 {
-    if (token != renderToken) {
+    kDebug() << request.token << renderToken;
+    if (request.token != renderToken) {
         //kDebug() << "render token mismatch" << token << renderToken;
         return;
     }
 
     if (cacheRendering) {
-        q->insertIntoCache(cacheKey(sourceImagePath, size, resizeMethod, color), image);
+        q->insertIntoCache(cacheKey(request.file, request.size, request.resizeMethod, request.color), image);
     }
 
     //kDebug() << "rendering complete!";
diff --git a/plasma/wallpaper.h b/plasma/wallpaper.h
index 43a859b..9d21e3c 100644
--- a/plasma/wallpaper.h
+++ b/plasma/wallpaper.h
@@ -286,7 +286,7 @@ class PLASMA_EXPORT Wallpaper : public QObject
 
         /**
          * Allows one to set rendering hints that may differ from the actualities of the
-         * Wallpaper's current state, allowing for better selection of papers from packages, 
+         * Wallpaper's current state, allowing for better selection of papers from packages,
          * for instance.
          *
          * @arg resizeMethod The resize method to assume will be used for future wallpaper
@@ -298,7 +298,7 @@ class PLASMA_EXPORT Wallpaper : public QObject
 
         /*
          * Allows one to set rendering hints that may differ from the actualities of the
-         * Wallpaper's current state, allowing for better selection of papers from packages, 
+         * Wallpaper's current state, allowing for better selection of papers from packages,
          * for instance.
          *
          * @arg targetSize The size to assume will be used for future wallpaper scaling
@@ -397,7 +397,7 @@ class PLASMA_EXPORT Wallpaper : public QObject
         /**
          * Sets whether or not to cache on disk the results of calls to render. If the wallpaper
          * changes often or is innexpensive to render, then it's probably best not to cache them.
-         * 
+         *
          * The default is not to cache.
          *
          * @see render
@@ -435,9 +435,8 @@ class PLASMA_EXPORT Wallpaper : public QObject
         void insertIntoCache(const QString& key, const QImage &image);
 
     private:
-        Q_PRIVATE_SLOT(d, void renderCompleted(int token, const QImage &image,
-                                               const QString &sourceImagePath, const QSize &size,
-                                               int resizeMethod, const QColor &color))
+        Q_PRIVATE_SLOT(d, void newRenderCompleted(const WallpaperRenderRequest &request,
+                                                  const QImage &image))
 
         friend class WallpaperPackage;
         friend class WallpaperPrivate;
